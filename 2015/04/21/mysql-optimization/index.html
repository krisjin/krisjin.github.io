<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>性能优化之MySQL优化 | krisjin博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.使用命令show variables like &apos;slow_query_log&apos;;  
查看到当前没有开启慢查询
2.使用命令show variables like ‘%log%’;也没有开启 log_queries_not_using_indexs
3.set global log_queries_not_using_indexes=on;4.show variables like ‘lon">
<meta property="og:type" content="article">
<meta property="og:title" content="性能优化之MySQL优化">
<meta property="og:url" content="http://krisjin.github.io/2015/04/21/mysql-optimization/index.html">
<meta property="og:site_name" content="krisjin博客">
<meta property="og:description" content="1.使用命令show variables like &apos;slow_query_log&apos;;  
查看到当前没有开启慢查询
2.使用命令show variables like ‘%log%’;也没有开启 log_queries_not_using_indexs
3.set global log_queries_not_using_indexes=on;4.show variables like ‘lon">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="性能优化之MySQL优化">
<meta name="twitter:description" content="1.使用命令show variables like &apos;slow_query_log&apos;;  
查看到当前没有开启慢查询
2.使用命令show variables like ‘%log%’;也没有开启 log_queries_not_using_indexs
3.set global log_queries_not_using_indexes=on;4.show variables like ‘lon">
  
    <link rel="alternative" href="/atom.xml" title="krisjin博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <script src="http://libs.baidu.com/jquery/1.9.0/jquery.js"></script>
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img lazy-src="" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">krisjin</a></h1>
		</hgroup>

		
		<p class="header-subtitle">一步一脚印</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">归档</a></li>
				        
							<li><a href="/readbook">读书</a></li>
				        
							<li><a href="/categories">分类</a></li>
				        
							<li><a href="/about">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/krisjin" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/cook99" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/NIO/" style="font-size: 10px;">NIO</a><a href="/tags/NLP/" style="font-size: 10px;">NLP</a><a href="/tags/TF-IDF/" style="font-size: 10px;">TF-IDF</a><a href="/tags/buffer/" style="font-size: 10px;">buffer</a><a href="/tags/cap/" style="font-size: 10px;">cap</a><a href="/tags/centos/" style="font-size: 10px;">centos</a><a href="/tags/channelpipeline/" style="font-size: 10px;">channelpipeline</a><a href="/tags/di/" style="font-size: 10px;">di</a><a href="/tags/gather/" style="font-size: 10px;">gather</a><a href="/tags/git/" style="font-size: 10px;">git</a><a href="/tags/git-server/" style="font-size: 10px;">git server</a><a href="/tags/guice/" style="font-size: 10px;">guice</a><a href="/tags/http/" style="font-size: 10px;">http</a><a href="/tags/idea/" style="font-size: 10px;">idea</a><a href="/tags/ioc/" style="font-size: 10px;">ioc</a><a href="/tags/java/" style="font-size: 10px;">java</a><a href="/tags/mybatis/" style="font-size: 10px;">mybatis</a><a href="/tags/mysql/" style="font-size: 10px;">mysql</a><a href="/tags/netty/" style="font-size: 20px;">netty</a><a href="/tags/nio/" style="font-size: 10px;">nio</a><a href="/tags/nosql/" style="font-size: 10px;">nosql</a><a href="/tags/redis/" style="font-size: 10px;">redis</a><a href="/tags/scatter/" style="font-size: 10px;">scatter</a><a href="/tags/thread/" style="font-size: 10px;">thread</a><a href="/tags/ubuntu/" style="font-size: 10px;">ubuntu</a><a href="/tags/websocket/" style="font-size: 10px;">websocket</a><a href="/tags/zookeeper/" style="font-size: 10px;">zookeeper</a><a href="/tags/关键字/" style="font-size: 10px;">关键字</a><a href="/tags/分布式/" style="font-size: 10px;">分布式</a><a href="/tags/创业，经验/" style="font-size: 10px;">创业，经验</a><a href="/tags/动态代理/" style="font-size: 10px;">动态代理</a><a href="/tags/并发/" style="font-size: 10px;">并发</a><a href="/tags/流程图/" style="font-size: 10px;">流程图</a><a href="/tags/阿里巴巴/" style="font-size: 10px;">阿里巴巴</a><a href="/tags/马云/" style="font-size: 10px;">马云</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">技术博客</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">krisjin</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">krisjin</h1>
			</hgroup>
			
			<p class="header-subtitle">一步一脚印</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">归档</a></li>
		        
					<li><a href="/readbook">读书</a></li>
		        
					<li><a href="/categories">分类</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/krisjin" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/cook99" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-mysql-optimization" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/04/21/mysql-optimization/" class="article-date">
  	<time datetime="2015-04-21T08:25:05.000Z" itemprop="datePublished">4月 21 2015</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      性能优化之MySQL优化
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/mysql/">mysql</a>
	</div>


        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-使用命令">1.使用命令</h2><pre><code><span class="operator"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slow_query_log'</span>;</span>  
</code></pre><p>查看到当前没有开启慢查询</p>
<h2 id="2-使用命令">2.使用命令</h2><p>show variables like ‘%log%’;<br>也没有开启 log_queries_not_using_indexs</p>
<h2 id="3-set_global_log_queries_not_using_indexes=on;">3.set global log_queries_not_using_indexes=on;</h2><h2 id="4-show_variables_like_‘long_query_time’;">4.show variables like ‘long_query_time’;</h2><p>查看到long_query_time的值为10，意思是慢查询日志中会记录超过十秒的记录;<a id="more"></a>  </p>
<p>默认情况下，MySQL是不会记录超过一定执行时间的SQL语句的。要开启这个功能，我们需要修改MySQL的配置文件，windows下修改my.ini,Linux  下修改my.cnf文件,在[mysqld]最后增加如下命令：</p>
<p>复制代码 代码如下:  </p>
<pre><code>slow_query_<span class="built_in">log</span>        
long_query_time = <span class="number">1</span>
</code></pre><h2 id="5-开启慢查询日志">5.开启慢查询日志</h2><pre><code><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="function_start"><span class="keyword">on</span></span>;  
</code></pre><p>导入mysql官方提供的sakila数据库：</p>
<p>将文件解压，得到三个文件，</p>
<p>打开cmd：使用命令 mysql -uroot -p &lt; “sakila-schema.sql所在的路径”  </p>
<p>使用命令 mysql -uroot -p &lt; “sakila-data.sql所在的路径”  </p>
<h2 id="6-mysql_慢查询日志分析工具">6.mysql 慢查询日志分析工具</h2><pre><code>mysqldumpslow  
pt-<span class="keyword">query</span>-digest
</code></pre><h2 id="7-如何通过慢查询日志发现有问题的SQL">7.如何通过慢查询日志发现有问题的SQL</h2><p><strong>查询次数多且每次查询所占用的时间长的SQL</strong>  </p>
<blockquote>
<p>通常为pt-query-digest分析的前几个查询</p>
</blockquote>
<p><strong>IO大的SQL</strong></p>
<blockquote>
<p>注意pt-query-digest分析中的Rows exammine项</p>
</blockquote>
<p><strong>未命中索引的SQL</strong> </p>
<blockquote>
<p>注意pt-query-digest分析中的Rows    examine和Rows Send的对比</p>
</blockquote>
<h2 id="8-使用explain查询SQL的执行计划">8.使用explain查询SQL的执行计划</h2><p><strong>explain返回各列的含义</strong></p>
<blockquote>
<ul>
<li><strong>table</strong>：显示这一行的数据是关于哪张表的  </li>
<li><strong>type</strong>：这是重要的列，显示连接使用了何种类型。从最好到最差的连续类型为const,eq_reg,ref,range,index和ALL(，没有where从句，表扫描)。   </li>
<li><strong>possible_keys</strong>:显示可能应用在这张表中的索引。如果为空，没有可能的索引  </li>
<li><strong>key</strong>:实际使用的索引。如果为NULL，则没有使用索引  </li>
<li><strong>key_len</strong>:使用的索引的长度。在不损失精确性的情况下，长度越短越好  </li>
<li><strong>ref</strong>：显示索引的哪一列被使用了，如果可能的话，是一个常数  </li>
<li><strong>rows</strong>：mysql认为必须检查的用来返回请求数据的行数  </li>
</ul>
</blockquote>
<h2 id="9-Max()的优化方法">9.Max()的优化方法</h2><p><strong>查询最后支付时间——优化MAX()函数</strong></p>
<pre><code><span class="operator"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">max</span>(payment_date) <span class="keyword">from</span> payment;</span>  
</code></pre><p>可以查看到：type:ALL是表扫描操作;没有任何索引，rows非常大，IO效率非常低。</p>
<p><strong>如何优化这个SQL：通常情况下建立索引：</strong></p>
<pre><code><span class="operator"><span class="keyword">create</span> <span class="keyword">index</span> idx_paydate <span class="keyword">on</span> payment(payment_date);</span>
</code></pre><p>这样在次执行</p>
<pre><code><span class="operator"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">max</span>(payment_date) <span class="keyword">from</span> payment;</span>  
</code></pre><p>可以看到Extra：select tables optimized away;可以通过索引进行操作，大大减少了IO操作</p>
<h2 id="10-Count()的优化方法">10.Count()的优化方法</h2><p>在一条SQL中同时查出2006年和2007年电影的数量——优化count()函数</p>
<p>错误方式：</p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(release_year=<span class="string">'2006'</span> <span class="keyword">OR</span> release_year=<span class="string">'2007'</span>) <span class="keyword">FROM</span> film;</span>
</code></pre><p>无法分开计算2006和2007年的电影数量</p>
<pre><code><span class="operator"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">FROM</span> film <span class="keyword">WHERE</span> release_year=<span class="string">'2006'</span> <span class="keyword">AND</span> release_year=<span class="string">'2007'</span>;</span>
</code></pre><p>release_year不可能同时为2006和2007，因此有逻辑错误</p>
<p>正确的方式：</p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(release_year=<span class="string">'2006'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> <span class="string">'2006年电影数量'</span>,<span class="keyword">COUNT</span>(release_year=<span class="string">'2007'</span> <span class="keyword">OR</span> <span class="literal">NULL</span>) <span class="keyword">AS</span> <span class="string">'2007年电影数量'</span> <span class="keyword">FROM</span> film;</span>
</code></pre><p>现在说说count(*)和count(id)的区别:</p>
<blockquote>
<p>新建一张表：create table t(id int);</p>
<p>插入数据：insert into t values (1),(2),(null);</p>
<p>当我们使用命令：select count(*),count(id) from t;</p>
<p>显示出count(*)为3，而count(id)为2;</p>
<p>说明count(*)包含了null的，count(id)不包含值为null的</p>
</blockquote>
<h2 id="11-子查询的优化">11.子查询的优化</h2><ul>
<li>通常情况下，需要把子查询优化为join查询，但在优化时要注意关联键是否有一对多的关系，要注意重复数据。<br>我们新建一张表t1  </li>
<li>create table t1(tid int);</li>
</ul>
<p>插入一条数据insert into t1 values(1);</p>
<p>进行子查询：</p>
<pre><code><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> t.id <span class="keyword">in</span> (<span class="keyword">select</span> * <span class="keyword">from</span> t1.tid <span class="keyword">from</span> t1);</span>
</code></pre><p>返回t表id在t1表中的数据</p>
<ul>
<li><p>优化成join的形式：  </p>
<pre><code>select t.<span class="property">id</span> <span class="keyword">from</span> t join t1 <span class="function_start"><span class="keyword">on</span></span> t.<span class="property">id</span>=t1.tid;
</code></pre></li>
</ul>
<p>这两种形式返回的结果是一样的</p>
<ul>
<li>需要注意的是：<br>如果在t1表中，添加一条数据：insert into t1 values(1);</li>
</ul>
<p>然后在分别执行这两种形式的查询：</p>
<p>发现使用select <em> from t where t.id in (select </em> from t1.tid from t1);查询出来的结果是一条数据。而select t.id from t join t1 on t.id=t1.tid;是两条数据，说明有重复数据，我们可以使用distinct去重</p>
<pre><code>select <span class="keyword">distinct</span> t.id <span class="keyword">from</span> t join t1 on t.id=t1.tid;这样就返回一条记录了
</code></pre><h2 id="12-优化group_by查询">12.优化group by查询</h2><pre><code><span class="operator"><span class="keyword">explain</span> <span class="keyword">SELECT</span> actor.first_name,actor.last_name,<span class="keyword">count</span>(*) <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sakila.actor <span class="keyword">USING</span>(actor_id) <span class="keyword">GROUP</span> <span class="keyword">BY</span> film_actor.actor_id;</span>  
</code></pre><p>using可用在join语句相同字段连接，起到和ON相同作用，inner join 和left join中都可以使用</p>
<p>示例：LEFT JOIN 正常写法：</p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> t1.id,t2.name <span class="keyword">FROM</span> t1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> t2 <span class="keyword">ON</span> t1.id=t2.id <span class="keyword">WHERE</span> ....  </span>
</code></pre><p>其实也可以这么写：</p>
<pre><code>SELECT t1<span class="class">.id</span>,t2<span class="class">.name</span> FROM t1 LEFT JOIN t2 <span class="function"><span class="title">USING</span><span class="params">(id)</span></span> WHERE ....
</code></pre><p>上面的explain执行结果，可以看到extra为Using temporary，Using filesort  用到了临时表,文件排序的方式对表进行了全表扫描.</p>
<p>我们应该避免这种方式。改写如下：</p>
<pre><code><span class="operator"><span class="keyword">Explain</span> <span class="keyword">SELECT</span> actor.first_name,actor.last_name,c.cnt  <span class="keyword">FROM</span> sakila.actor <span class="keyword">INNER</span> <span class="keyword">JOIN</span>(<span class="keyword">SELECT</span> actor_id,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> cnt <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">GROUP</span> <span class="keyword">BY</span> actor_id) <span class="keyword">AS</span> c <span class="keyword">USING</span>(actor_id);</span>
</code></pre><h2 id="13-优化limit查询">13.优化limit查询</h2><p>limit常用于分页处理，时常会伴随order by从句使用，因此大多时候会使用Filesorts，这样会造成大量的IO问题</p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> film_id,description <span class="keyword">FROM</span> sakila.film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span>;</span>  
</code></pre><p>这个语句进行explain操作，发现会进行全表扫描，并且有文件排序的方式</p>
<p>优化方式：</p>
<p><strong>步骤1.使用有索引的列或主键进行Order By操作</strong> </p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> film_id,description <span class="keyword">FROM</span> sakila.film <span class="keyword">ORDER</span> <span class="keyword">BY</span> film_id <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span>  </span>
</code></pre><p>使用这种方式可以得到相同的结果，但是explain执行计划却完全不同，type=index,rows=55  </p>
<p>这种方式并不是最优的，比如将limit 50,5改为limit 500,5;rows=505，rows会随着limit而改变，如果有上万条数据，那么响应速度回变慢</p>
<p><strong>步骤2.记录上次返回的主键，在下次查询时使用主键过滤</strong>  </p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> film_id,description <span class="keyword">FROM</span> sakila.film <span class="keyword">WHERE</span> film_id&gt;<span class="number">55</span> <span class="keyword">and</span> film_id&lt;=<span class="number">60</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> film_id <span class="keyword">LIMIT</span> <span class="number">1</span>,<span class="number">5</span>;</span>  
</code></pre><p>这种方式rows=5，并且不会随着limit的增长而增长  </p>
<h2 id="14-索引优化">14.索引优化</h2><ul>
<li>在where从句，group by从句，order by 从句，on从句中出现的列  </li>
<li>索引字段越小越好  </li>
<li><p>离散度越大的列放到联合索引的前面    </p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> payment <span class="keyword">WHERE</span> staff_id=<span class="number">2</span> <span class="keyword">AND</span> customer_id =<span class="number">584</span>;</span>
</code></pre></li>
</ul>
<p>是index(staff_id,customer_id)好?还是index(customer_id,staff_id)好?  </p>
<p>首先我们先看一下payment表的数据结构是什么样的</p>
<pre><code><span class="keyword">desc</span> payment;
</code></pre><p>然后我们使用语句:select count(distinct customer_id),count(distinct staff_id) from payment;这样我们可以看出他们的离散程度。他们的唯一值越多，说明他们的离散度越好，他们的可选择性就越高。  </p>
<p>这个查询可以看出 customer_id=599，而staff_id=2;说明customer_id离散度更高一些，可选择性更高，因此要建立联合索引时就把customer_id放在最前面。</p>
<p>所以应该使用index(customer_id,staff_id)</p>
<h2 id="15-如何选择合适的列建立索引?">15.如何选择合适的列建立索引?</h2><p><strong>索引不是越多越好</strong></p>
<p>通常情况下建立索引可以优化我们的查询效率，但是会降低我们的写入效率，也就是说建立索引会增强查询，会影响insert，update，delete这种写入操作。但是往往不是这样的，过多的索引不但会影响我们的写入效率，同时也会影响查询，这是由于数据库进行查询分析的时候，首先要选择哪个索引进行查询，如果索引越多，分析的过程就越慢，这样就会影响查询的效率。因此我们要维护和删除索引。</p>
<p><strong>索引的维护及优化—-重复及冗余索引</strong><br>重复索引是指相同的列以相同的顺序建立同类型的索引，如下表primary key 和ID列上的索引就是重复索引(主键已经是一个唯一索引了)：</p>
<pre><code><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> test(id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">primary</span> <span class="keyword">key</span>,name <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="literal">null</span>,title <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> ,<span class="keyword">unique</span>(id))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span>  
</code></pre><p>冗余索引是指多个索引的前缀列相同，或者是在联合索引中包含了主键的索引，下面这个例子中key(name,id)就是一个冗余索引。</p>
<pre><code><span class="operator"><span class="keyword">create</span> <span class="keyword">table</span> test(id <span class="built_in">int</span> <span class="literal">null</span> <span class="keyword">primary</span> <span class="keyword">key</span>,name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,title <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,<span class="keyword">key</span>(name,id))<span class="keyword">engine</span>=<span class="keyword">innodb</span>;</span>  
</code></pre><p><strong>查找重复及冗余索引</strong>  </p>
<pre><code><span class="operator"><span class="keyword">SELECT</span> a.TABLE_SCHEMA <span class="keyword">AS</span> <span class="string">'数据库名'</span>,a.table_name <span class="keyword">as</span> <span class="string">'表名'</span>,a.index_name <span class="keyword">AS</span> <span class="string">'索引1'</span>,b.INDEX_NAME <span class="keyword">AS</span> <span class="string">'索引  2'</span>,a.COLUMN_NAME <span class="keyword">AS</span> <span class="string">'重复列名'</span> <span class="keyword">FROM</span> STATISTICS a <span class="keyword">JOIN</span> STATISTICS b <span class="keyword">ON</span> a.TABLE_SCHEMA=b.TABLE_SCHEMA <span class="keyword">AND</span>   a.TABLE_NAME=b.TABLE_NAME <span class="keyword">AND</span> a.SEQ_IN_INDEX=b.SEQ_IN_INDEX <span class="keyword">AND</span> a.COLUMN_NAME=b.COLUMN_NAME <span class="keyword">WHERE</span> a.SEQ_IN_INDEX = <span class="number">1</span> <span class="keyword">AND</span> a.INDEX_NAME &lt;&gt; b.INDEX_NAME;</span>
</code></pre><p><strong>工具：使用pt-duplicate-key-checker工具</strong>  </p>
<p><strong>删除不用的索引，目前mysql中只能使用慢查询日志配合pt-index-usage工具来进行索引使用情况的分析</strong></p>
<h2 id="16-数据库结构优化">16.数据库结构优化</h2><p><strong>选择合适的数据类型</strong></p>
<p>数据类型的选择，重点在于”合适”二字，如何确定选择的数据类型是否合适？</p>
<blockquote>
<ol>
<li>使用可以存下你的数据的最小的数据类型  </li>
<li>使用简单的数据类型。Int要比varchar类型在mysql处理上简单  </li>
<li>尽可能的时候not null定义字段  </li>
<li>尽量少用text类型，非用不可是最好考虑分表<br>使用bigint来存储ip地址，利用INET_ATON(),INET_NTOA()两个函数来进行转换</li>
</ol>
</blockquote>
<pre><code><span class="operator"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sessions(id <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">NOT</span> <span class="literal">NULL</span>,ipaddress <span class="built_in">BIGINT</span>,<span class="keyword">PRIMARY</span> <span class="keyword">KEY</span>(id));</span>

<span class="operator"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">session</span>(ipaddress) <span class="keyword">VALUES</span>(<span class="keyword">INET_ATON</span>(<span class="string">'192.168.0.1'</span>));</span>

<span class="operator"><span class="keyword">SELECT</span> INET_NTOAA(ipaddress) <span class="keyword">FROM</span> sessions;</span>
</code></pre><p><strong>表的范式化和反范式化</strong></p>
<p>范式化是指数据库设计的规范，目前说到范式化一般是指第三范式，也就是要求数据库中不存在非关键字段对任意候选关键字段的传递函数依赖则符合第三范式</p>
<p>反范式化是指为了查询效率的考虑把原本符合第三范式的表适当的增加冗余，已达到优化查询效率的目的，反范式化是一种以空间来换取时间的操作。</p>
<p><strong>表的垂直拆分</strong></p>
<p>所谓的垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。通常垂直拆分可以按以下原则进行：</p>
<blockquote>
<ol>
<li>把不常用的字段单独存放到一个表中。  </li>
<li>把大字段独立存放到一个表中。  </li>
<li>把经常一起使用的字段放到一起。  </li>
</ol>
</blockquote>
<p><strong>表的水平拆分</strong></p>
<p>表的水平拆分是为了解决单表的数据量过大的问题，水平拆分的表每一个表的结构都是完整一致的。</p>
<p>常用的水平拆分方法为：</p>
<blockquote>
<ol>
<li>对id进行hash运算，如果要拆分成5个表则使用mod(id,5)取出0-4个值</li>
<li>针对不同的hashID把数据存到不同的表中。</li>
</ol>
</blockquote>
<p>挑战：1.快分区表进行数据查询2.统计及后台报表操作</p>
<h2 id="17-操作系统配置优化">17.操作系统配置优化</h2><p>数据库是基于操作系统的，目前大多数Mysql都是安装在Linux系统之上，所以对于操作系统的一些参数配置也会影响到Mysql的性能，下面就列出一些常用的系统配置</p>
<p>网络方面的配置，要修改/etc/sysctl.conf</p>
<pre><code>#增加tcp支持的队列数

net<span class="class">.ipv4</span><span class="class">.tcp_max_syn_backlog</span> = <span class="number">65535</span>

#减少断开连接时，资源回收

net<span class="class">.ipv4</span><span class="class">.tcp_max_tw_buckets</span> = <span class="number">8000</span>

net<span class="class">.ipv4</span><span class="class">.tcp_tw_reuse</span> = <span class="number">1</span>

net<span class="class">.ipv4</span><span class="class">.tcp_tw_recycle</span> = <span class="number">1</span>

net<span class="class">.ipv4</span><span class="class">.tcp_fin_timeout</span> = <span class="number">10</span>


#打开文件数的限制，可以使用ulimit -a查看目录的各位限制，可以修改/etc/security/limits.conf文件，增加以下内容以修改打开文件数量的限制
soft nofile <span class="number">65535</span>
hard nofile <span class="number">65535</span>
</code></pre><p>除此之外最好在Mysql服务器上关闭iptable,selinux等防火墙软件</p>
<h2 id="18-mysql配置文件">18.mysql配置文件</h2><p>Mysql可以通过启动时指定配置文件参数和使用配置文件两种方法进行配置，在大多数情况下配置文件位于/etc/my.cnf或是/etc/mysql/my.cnf，在windows系统配置文件可以是位于C:/windows/my.ini文件，Mysql查找配置文件的顺序可以通过以下方法获得</p>
<pre><code>$/usr/sbin/mysqld --<span class="keyword">verbose</span> --<span class="keyword">help</span>|<span class="keyword">grep</span> -A <span class="keyword">l</span> <span class="string">'Default option'</span>
</code></pre><p>注意：如果存在多个位置存在配置文件，则后面的会覆盖前面的</p>
<p>Mysql配置文件—常用参数说明</p>
<pre><code>innodb_buffer_pool-size：非常重要的一个参数，用于配置Innodb的缓冲池，如果数据库中个只有Innodb表，则推荐配置量为总内存的<span class="number">75</span>%.

<span class="label">innodb_buffer_pool_instances:</span>Mysql5.5中新增加参数，可以控制缓冲池的个数，默认情况下只有一个缓冲池

<span class="label">Innodb_log_buffer_size:</span>innodb log 缓冲的大小，由于日志最长每秒钟就会刷新所以一般不用太大

<span class="label">innodb_flush_log_at_trx_commit:</span>关键参数，对innodb的IO效率影响很大。默认值为<span class="number">1</span>,可以取<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>三个值，一般建议设为<span class="number">2</span>，但如果数据安全性要求比较高则使用默认值<span class="number">1.</span>

innodb_read_io_threads,innodb_write_io_threads：决定了Innodb读写的IO进程数，默认为<span class="number">4</span>

<span class="label">innodb_file_per_table:</span>关键参数，控制Innodb每一个表使用独立的表空间，默认为off，也就是所有表都会建立在共享表空间中

<span class="label">innodb_stats_on_metadata:</span>决定了Mysql在什么情况下会刷新innodb表的统计信息
</code></pre><h2 id="19-第三方工具：Percon_Configuration_Wizard">19.第三方工具：Percon Configuration Wizard</h2><h2 id="20-服务器硬件优化：">20.服务器硬件优化：</h2><p><strong>如何选择CPU</strong>：是选择单核更快的CPU还是选择核数更多的cup?</p>
<blockquote>
<ol>
<li><p>MySQL有一些工作只能用到单核CPU</p>
</li>
<li><p>Mysql对CPU核数的支持并不是越多越快</p>
</li>
</ol>
</blockquote>
<p>mysql5.5使用的服务器不要超过32核</p>
<p><strong>磁盘IO优化：</strong></p>
<p>常用RAID级别介绍：</p>
<p>RAID0:也称为条带，就是把多个磁盘链接成一个硬盘使用，这个级别的IO最好，缺点就是一个磁盘坏掉那么所有数据就会丢失</p>
<p>RAID1：也称为镜像，要求至少有两个磁盘，每组磁盘存储的数据相同，IO效果不如RAID0，安全性好</p>
<p>RAID5：也是把多个(最少3个)硬盘合并成一个逻辑盘使用，数据读写时会建立奇偶校验信息，并且奇偶校验信息和相对应的数据分别存储于不同的磁盘上。当RAID5的一个磁盘数据发生损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。</p>
<p>一般的OLTP型的数据库使用RAID1+0：就是RAID1和RAID0的结合。同时具有两个级别的优缺点。一般建议数据库使用这个级别。</p>
<p><strong>SNA和NAT是否合适数据库：</strong></p>
<blockquote>
<ol>
<li>常用于高可用解决方案</li>
<li>顺序读写效率高，但是随即读写不如人意</li>
<li>数据库随即读写比率很高。</li>
</ol>
</blockquote>
<p>转载自：<a href="http://get.jobdeer.com/7055.get" target="_blank" rel="external">Get社区</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/04/22/cap/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          持续可用与CAP理论 – 一个系统开发者的观点
        
      </div>
    </a>
  
  
    <a href="/2015/04/15/Recommen-System/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">58推荐系统学习</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="mysql-optimization" data-title="性能优化之MySQL优化" data-url="http://krisjin.github.io/2015/04/21/mysql-optimization/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"krisjin"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>



</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 krisjin
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/mobile.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>





<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>